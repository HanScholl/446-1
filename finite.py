# -*- coding: utf-8 -*-
"""finite.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dy35Kn5TmAqiBAoGkb-J3iVrmGdkVnJD
"""

import numpy as np
from scipy.sparse import lil_matrix, csr_matrix

class DifferenceUniformGrid:
    def __init__(self, num_points, period_length):
        self.num_points = num_points
        self.period_length = period_length
        self.values = np.linspace(0, period_length, num_points)


class UniformPeriodicGrid:
    def __init__(self, derivative, convergence, grid):
        self.derivative = derivative
        self.convergence = convergence + 1
        self.h = grid.period_length / grid.num_points
        self.N = len(grid.values)
        self.points = self.generate_stencil(self.derivative, self.convergence-1)
        coeff = self.taylor_series_coefficients(len(self.points), self.points)
        fin_dif_coeff = self.create_array(len(self.points), len(self.points), coeff)
        rhs = np.zeros(len(self.points))
        rhs[self.derivative] = 1
        self.solution = np.linalg.solve(fin_dif_coeff, rhs)/(self.h ** self.derivative)
        self.matrix = self.construct_matrix()

    def construct_matrix(self):

        stencil_radius = ((len(self.solution)) // 2)

        # Initialize a sparse matrix (LIL format for incremental construction)
        mat = lil_matrix((self.N, self.N))

        # Loop over each grid point to populate the matrix
        for i in range(self.N):
            # Loop over the stencil coefficients
            for j, coeff in enumerate(self.solution):
                # Calculate the correct index considering periodic boundaries
                idx = (i + j - stencil_radius) % self.N
                mat[i, idx] = coeff

        # Convert to CSR format for efficient matrix-vector multiplication
        return mat.tocsr()

    def generate_stencil(self, order, convergence):
        if order == 1:
            # Integers from -convergence/2 to convergence/2, excluding 0
            stencil = np.array([i for i in range(-convergence//2, convergence//2 + 1)])
        elif order == 2:
            # Integers from -convergence/2 to convergence/2, including 0
            stencil = np.array([i for i in range(-convergence//2, convergence//2 + 1)])
        elif order == 3:
            # Integers from -((convergence/2)+1) to (convergence/2)+1, excluding 0
            stencil = np.array([i for i in range(-((convergence//2)+1), (convergence//2)+2)])
        elif order >= 0 and convergence >= 0:
            # Take order + convergence points on either side
            num_points = order + convergence
            if num_points % 2 == 0:
                # Include 0 if the total number of points is even
                stencil = np.array([i for i in range(-num_points//2, num_points//2 + 1)])
            else:
                # Exclude 0 if the total number of points is odd
                stencil = np.array([i for i in range(-num_points//2, num_points//2 + 1) ])
        return stencil

    def taylor_series_coefficients(self, order, user_array):
        all_coefficients = []
        for base in user_array:
            coefficients = []
            for i in range(order):
                coefficients.append((base ** i) / (np.math.factorial(i)))
            all_coefficients.append(coefficients)
        return all_coefficients

    def create_array(self, n, p, list_input):
        output_array = np.zeros((p, n), dtype=float)
        for j in range(p):
            for i in range(n):
                output_array[j, i] = list_input[i][j]
        return np.array(output_array)